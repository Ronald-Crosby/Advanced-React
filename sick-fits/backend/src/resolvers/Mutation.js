const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { randomBytes } = require('crypto');
const { promisify } = require('util');
const { transport, makeANiceEmail } = require('../mail');

const Mutation = {
  async createItem(parent, args, ctx, info) {
    // TODO: check if theyre logged in

    // this is how we access the db that we added to context earlier in the createServer file
    const item = await ctx.db.mutation.createItem(
      {
        data: {
          ...args,
        },
      },
      info
    );
    return item;
  },

  updateItem(parent, args, ctx, info) {
    // first take a copy of the updates
    const updates = { ...args };
    // remove id from updates
    delete updates.id;
    // run the update method
    return ctx.db.mutation.updateItem(
      {
        data: updates,
        where: {
          // we need to reference the id but weve deleted updated.id. this is why we spread the args values into a new object and assign it to updates above.
          id: args.id,
        },
      },
      info
    );
  },

  async deleteItem(parent, args, ctx, info) {
    const where = { id: args.id };
    // 1. find the item
    const item = await ctx.db.query.item({ where }, `{ id title }`);
    // 2. check if they have permissions
    // TODO
    // 3. delete it
    return ctx.db.mutation.deleteItem({ where }, info);
  },

  async signup(parent, args, ctx, info) {
    // downcase the email
    args.email = args.email.toLowerCase();
    // create password variable of hash of password
    const password = await bcrypt.hash(args.password, 10);
    // create the user in the database. the createUser() method is generated by prisma and comes from our prisma.graphql file
    const user = await ctx.db.mutation.createUser(
      {
        data: {
          // this is the same as copying out email: args.email and so on
          ...args,
          // overwrite args.password with our password hash variable
          password,
          // because permission is an array of enums, it is set like this:
          permissions: { set: ['USER'] },
        },
      },
      info
    );
    // create json web token (jwt) for the new user
    const token = jwt.sign({ userId: user.id }, process.env.APP_SECRET);
    // set a cookie with the token and other info we need
    ctx.response.cookie('token', token, {
      // this is for security reasons
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 365, // one year max age
    });
    // return user to the browser
    return user;
  },

  async signin(parent, args, ctx, info) {
    // 1, check if there is a user associated with args.email
    const user = await ctx.db.query.user({ where: { email: args.email } });
    if (!user) {
      throw new Error(`No user found for ${args.email}`);
    }
    // 2. check if the password is correct. use the bcrypt.compare() method to check if the password in the args (that comes from the signup form) and the password in the database are the same.
    const valid = await bcrypt.compare(args.password, user.password);
    if (!valid) {
      throw new Error(`Invalid password`);
    }
    // 3. generate the JWT token
    const token = jwt.sign({ userId: user.id }, process.env.APP_SECRET);
    // 4. set the token in a cookie on the browser
    ctx.response.cookie('token', token, {
      // this is for security reasons
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 365, // one year max age
    });
    // 5. return the User
    return user;
  },

  signout(parent, args, ctx, info) {
    ctx.response.clearCookie('token');
    return { message: 'Goodbye' };
  },

  async requestreset(parent, args, ctx, info) {
    // 1, check if there is a user associated with args.email
    const user = await ctx.db.query.user({ where: { email: args.email } });
    if (!user) {
      throw new Error(`No user found for ${args.email}`);
    }
    // 2. create a token with 1 hour expiry
    const resetToken = (await promisify(randomBytes)(20)).toString('hex');
    const resetTokenExpiry = Date.now() + 3600000; // 1 hour from now
    // use the updateUser mutation to add the token and expiry time to the database
    const res = await ctx.db.mutation.updateUser({
      where: { email: args.email },
      data: { resetToken, resetTokenExpiry },
    });
    // 3. email them the token
    const mailResponse = await transport.sendMail({
      from: 'ollythedeveloper@gmail.com',
      to: user.email,
      subjectLine: 'Your password reset token',
      html: makeANiceEmail(
        `<p>Your password reset token is here: \n\n 
          <a href="${process.env.FRONTEND_URL}/reset?reset_token=${resetToken}">click here to reset your password</a>
        </p>`
      ),
    });
    // return message
    return { message: 'thanks' };
  },

  async resetPassword(parent, args, ctx, info) {
    // 1. check if the password and password confirmation match
    if (args.password !== args.confirmPassword) {
      throw new Error(`Passwords do not match`);
    }
    // 2. check if the reset token is valid
    // 3. check if the reset token is expired
    const [user] = await ctx.db.query.users({
      where: {
        resetToken: args.resetToken,
        resetTokenExpiry_gte: Date.now() - 3600000,
      },
    });
    if (!user) {
      throw new Error(
        'This token is either invalid or expired. tokens are valid for one hour.'
      );
    }
    // 4. hash the new password (args.password)
    const password = await bcrypt.hash(args.password, 10);
    // 5. update the password in the database to the new password
    // use the updateUser mutation, select the user again, this time using our local user.email and then set the password using our local password and set the resetToken to be null. We will want to return the updated user later so we assign it to a variable.
    const updatedUser = await ctx.db.mutation.updateUser({
      where: { email: user.email },
      data: {
        password,
        resetToken: null,
        resetTokenExpiry: null,
      },
    });
    // 5. create a new JWT
    const token = jwt.sign({ userId: updatedUser.id }, process.env.APP_SECRET);
    // 6. set the new JWT on the browser so the user is now logged in
    ctx.response.cookie('token', token, {
      // this is for security reasons
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 365, // one year max age
    });
    // 7. return the new user
    return updatedUser;
  },
};

module.exports = Mutation;
