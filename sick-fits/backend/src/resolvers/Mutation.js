const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const Mutation = {
  async createItem(parent, args, ctx, info) {
    // TODO: check if theyre logged in

    // this is how we access the db that we added to context earlier in the createServer file
    const item = await ctx.db.mutation.createItem(
      {
        data: {
          ...args,
        },
      },
      info
    );
    return item;
  },

  updateItem(parent, args, ctx, info) {
    // first take a copy of the updates
    const updates = { ...args };
    // remove id from updates
    delete updates.id;
    // run the update method
    return ctx.db.mutation.updateItem(
      {
        data: updates,
        where: {
          // we need to reference the id but weve deleted updated.id. this is why we spread the args values into a new object and assign it to updates above.
          id: args.id,
        },
      },
      info
    );
  },

  async deleteItem(parent, args, ctx, info) {
    const where = { id: args.id };
    // 1. find the item
    const item = await ctx.db.query.item({ where }, `{ id title }`);
    // 2. check if they have permissions
    // TODO
    // 3. delete it
    return ctx.db.mutation.deleteItem({ where }, info);
  },

  async signup(parent, args, ctx, info) {
    // downcase the email
    args.email = args.email.toLowerCase();
    // create password variable of hash of password
    const password = await bcrypt.hash(args.password, 10);
    // create the user in the database. the createUser() method is generated by prisma and comes from our prisma.graphql file
    const user = await ctx.db.mutation.createUser(
      {
        data: {
          // this is the same as copying out email: args.email and so on
          ...args,
          // overwrite args.password with our password hash variable
          password,
          // because permission is an array of enums, it is set like this:
          permissions: { set: ['USER'] },
        },
      },
      info
    );
    // create json web token (jwt) for the new user
    const token = jwt.sign({ userId: user.id }, process.env.APP_SECRET);
    // set a cookie with the token and other info we need
    ctx.response.cookie('token', token, {
      // this is for security reasons
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 365, // one year max age
    });
    // return user to the browser
    return user;
  },

  async signin(parent, args, ctx, info) {
    // 1, check if there is a user associated with args.email
    const user = await ctx.db.query.user({ where: { email: args.email } });
    if (!user) {
      throw new Error(`No user found for ${args.email}`);
    }
    // 2. check if the password is correct. use the bcrypt.compare() method to check if the password in the args (that comes from the signup form) and the password in the database are the same.
    const valid = await bcrypt.compare(args.password, user.password);
    if (!valid) {
      throw new Error(`Invalid password`);
    }
    // 3. generate the JWT token
    const token = jwt.sign({ userId: user.id }, process.env.APP_SECRET);
    // 4. set the token in a cookie on the browser
    ctx.response.cookie('token', token, {
      // this is for security reasons
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 365, // one year max age
    });
    // 5. return the User
    return user;
  },

  async signout(parent, args, ctx, info) {
    ctx.response.clearCookie('token');
    return { message: 'Goodbye' };
  },
};

module.exports = Mutation;
